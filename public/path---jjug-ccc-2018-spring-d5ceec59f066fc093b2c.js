webpackJsonp([82162071098711],{510:function(l,n){l.exports={data:{site:{siteMetadata:{title:"たかはしメモ",author:"Ryota Takahashi"}},markdownRemark:{id:"/Users/ryota/workspace/blog/src/pages/jjug-ccc-2018-spring/index.md absPath of file >>> MarkdownRemark",html:'<h2>概要</h2>\n<ul>\n<li>日本 Java ユーザグループ主催のコミュニティカンファレンス</li>\n<li>2018/5/26 Sat 10:00 - 18:30</li>\n<li>ベルサール新宿グランド コンファレンスセンター 5F</li>\n</ul>\n<h2>Java で Web サービスを作り続けるための戦略と戦術</h2>\n<ul>\n<li>開発環境とは、プログラマ以外のデザイナ、サービス側などのエンジニア以外も使う</li>\n<li>開発、検証環境が動かない → 別バージョンのアプリがデプロイされているとか</li>\n<li>開発手順書じゃなくて、セットアップを自動化する</li>\n<li>\n<p>サービスごとに VM を作って、その上に Docker でアプリ、DB を稼働させる</p>\n<ul>\n<li>\n<p>Docker For Mac を使わなかった理由</p>\n<ul>\n<li>当時、動作が不安定だったので</li>\n<li>ローカルホストのポートが重複するので</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Docker の作成、運用はアプリケーションエンジニアの仕事</li>\n<li>\n<p>Maven から Gradleに移行</p>\n<ul>\n<li>並列ビルド</li>\n<li>xml はもう古い</li>\n</ul>\n</li>\n<li>Jenkins 2 の Jenkinsfile にビルド定義を書く</li>\n<li>\n<p>プルリクごとに開発/検証環境を用意できることが理想</p>\n<ul>\n<li>サービスが側にすぐ確認してもらえるように</li>\n</ul>\n</li>\n<li>Tomcat はインストールして eclipse から起動するのではなく、new Tomcat() する</li>\n<li>\n<p>JasperReport はオワコン</p>\n<ul>\n<li>Java 8 だとデザインツールが事実上動かない(2016 年当時)</li>\n</ul>\n</li>\n<li>\n<p>JSESSIONID はオワコン</p>\n<ul>\n<li>複数のアプリを起動すると、競合するので</li>\n<li>名前はアプリごとに変更可能</li>\n<li>\n<p>sticky-session-cookie もオワコン</p>\n<ul>\n<li>spring-session-… でラップすればよい</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>src/main/webapp じゃなく src/main/resources におく</li>\n</ul>\n<h2>Java 9 Variable Handles のイロハ</h2>\n<ul>\n<li>\n<p>Valhalla の由来</p>\n<ul>\n<li>Valhalla == VALue types に似ているから</li>\n</ul>\n</li>\n<li>\n<p>ライブラリ、フレームワーク開発者が主に使う機能</p>\n<ul>\n<li>Java 10 から</li>\n<li>sun.misc.Unsafe の代わりに使う</li>\n</ul>\n</li>\n<li>\n<p>sun.misc.Unsafe</p>\n<ul>\n<li>JDK の内部インターフェース API</li>\n<li>直接メモリを操作可能</li>\n<li>Reflection, Serializaion, NIO 等の実装で使用</li>\n<li>\n<p>Sun(Oracle) 以外の利用は想定外</p>\n<ul>\n<li>通常の開発で使うことはない</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Variable Handles</p>\n<ul>\n<li>データ単位ではなくアクセス単位でメモリ操作可能</li>\n<li>Java 9 まではアトミックな処理で unsafe を使うことがあった</li>\n<li>Java 10 以降は、 Var Handle を使う</li>\n</ul>\n</li>\n<li>\n<p>MethodHandle</p>\n<ul>\n<li>VarHandle の前提知識</li>\n<li>メソッドのポインタ</li>\n<li>関数ポインタ</li>\n<li>Reflection API の代替手段になる(パフォーマンスがよくなる事例がある)</li>\n<li>Field のアクセス、例外 throw、定数を返すとかできる</li>\n<li>\n<p>セキュリティチェックが発生しない</p>\n<ul>\n<li>チェックするオーバーヘッドを削減できる</li>\n<li>脆弱性になることがある</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>volatile → ボラティルって発音してた</li>\n</ul>\n<h2>LINE LIVE のチャットが 30,000+/min のコメント投稿をさばけるようになるまで</h2>\n<ul>\n<li>\n<p>WebSocket</p>\n<ul>\n<li>LINE LIVE チャットでは送信文字数が少ないので REST API をいちいち呼び出すと思い</li>\n</ul>\n</li>\n<li>\n<p>akka Actor Model</p>\n<ul>\n<li>actor に大きな処理をさせない(小さく分割することが重要)</li>\n<li>ブロッキングする処理をさせない</li>\n<li>\n<p>All for One strategy</p>\n<ul>\n<li>複数の子 actor を持っている場合に有用</li>\n<li>各アクター間の依存度が高く、crash したら他のアクターも失敗させることができる</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Java から TypeScript へ 切り替えて加速するサーバーレス開発</h2>\n<ul>\n<li>AWS Lambda を TypeScript で開発した話</li>\n<li>Lambda を使うとサーバの管理、メンテは不要になるので楽</li>\n<li>ランタイムが Java でコールドスタートした場合、遅いので Node.js にした</li>\n<li>Java 開発者だったら素の JavaScript じゃなくて TypeScript 使うと型の恩恵を受けられていい</li>\n<li>\n<p>Lambda がチェーンしているアーキテクチャがちょっと失敗だったかも</p>\n<ul>\n<li>各 Lambda がコールドスタートになるとかなり遅くなる</li>\n</ul>\n</li>\n</ul>\n<h2>DDDとクリーンアーキテクチャでサーバーアプリケーションを作っている話</h2>\n<ul>\n<li>\b\b作ったアプリケーションが密結合、ビジネス\bロジックを書くドメイン層がなかった</li>\n<li>DDD、クリーンアーキテクチャで作り直している</li>\n</ul>\n<h2>感想</h2>\n<ul>\n<li>フレームワークは Spring が主流な感じだった</li>\n<li>Docker 使うのはもう当たり前な感じ</li>\n<li>聞いているだけだったけど、最後は疲れちゃってメモが雑に、、、</li>\n</ul>\n<h2>スライド</h2>\n<ul>\n<li><a href="http://d.hatena.ne.jp/chiheisen/20180527/1527375138">\b\bこちら</a>のブログにいい感じでリンクが貼ってあります</li>\n</ul>',frontmatter:{title:"JJUG CCC 2018 Spring",date:"June 02, 2018"}}},pathContext:{slug:"/jjug-ccc-2018-spring/",previous:{fields:{slug:"/java-day-toko-2018/"},frontmatter:{title:"Java Day Tokyo 2018"}},next:null}}}});
//# sourceMappingURL=path---jjug-ccc-2018-spring-d5ceec59f066fc093b2c.js.map